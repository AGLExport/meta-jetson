From 1cac17ece10bf4d95b9efb5b2ed8586e0d60660c Mon Sep 17 00:00:00 2001
From: wata2ki <wata2ki@gmail.com>
Date: Wed, 13 Apr 2016 23:41:14 +0900
Subject: [PATCH 3/4] compositor-drm: Add support for Tegra Jetson TK1.

---
 src/compositor-drm.c | 93 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 90 insertions(+), 3 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 15ded72..5059fa1 100755
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -45,6 +45,9 @@
 
 #include <gbm.h>
 #include <libudev.h>
+#ifdef HAVE_DRM_TEGRA
+#include <tegra_drm.h>
+#endif
 
 #include "shared/helpers.h"
 #include "shared/timespec-util.h"
@@ -235,6 +238,32 @@ static struct gl_renderer_interface *gl_renderer;
 
 static const char default_seat[] = "seat0";
 
+static int
+drm_tegra_import(int fd, uint32_t handle)
+{
+#ifdef HAVE_DRM_TEGRA
+	struct drm_tegra_gem_set_tiling args;
+	int err;
+
+	memset(&args, 0, sizeof(args));
+	args.handle = handle;
+	args.mode = DRM_TEGRA_GEM_TILING_MODE_BLOCK;
+	args.value = 4;
+
+	err = ioctl(fd, DRM_IOCTL_TEGRA_GEM_SET_TILING, &args);
+	if (err < 0) {
+		weston_log("failed to set tiling parameters: %m\n");
+		return -errno;
+	}
+	return 0;
+#else
+	weston_log("DRM device is a tegra but weston compiled without "
+		   "libdrm tegra");
+
+	return -1;
+#endif
+}
+
 static void
 drm_output_set_cursor(struct drm_output *output);
 
@@ -377,6 +406,32 @@ drm_fb_get_from_bo(struct gbm_bo *bo,
 	fb->size = fb->stride * height;
 	fb->fd = backend->drm.fd;
 
+	if (backend->drm.fd != backend->gbm.fd) {
+		int fd;
+
+		ret = drmPrimeHandleToFD(backend->gbm.fd, fb->handle, 0,
+					 &fd);
+		if (ret) {
+			weston_log("failed to export bo: %m\n");
+			goto err_free;
+		}
+
+		ret = drmPrimeFDToHandle(backend->drm.fd, fd, &fb->handle);
+		if (ret) {
+			weston_log("failed to import bo: %m\n");
+			goto err_free;
+		}
+
+		close(fd);
+
+		ret = drm_tegra_import(backend->drm.fd, fb->handle);
+		if (ret < 0) {
+			weston_log("failed to import handle: %s\n",
+				   strerror(-ret));
+			goto err_free;
+		}
+	}
+
 	if (backend->min_width > width || width > backend->max_width ||
 	    backend->min_height > height ||
 	    height > backend->max_height) {
@@ -1487,8 +1542,14 @@ init_drm(struct drm_backend *b, struct udev_device *device)
 	b->drm.fd = fd;
 	b->drm.filename = strdup(filename);
 
-	b->gbm.fd = fd;
-	b->gbm.filename = b->drm.filename;
+	if (b->gbm.filename) {
+		fd = weston_launcher_open(b->compositor->launcher, b->gbm.filename,
+					  O_RDWR);
+		b->gbm.fd = fd;
+	} else {
+		b->gbm.fd = fd;
+		b->gbm.filename = b->drm.filename;
+	}
 
 	ret = drmGetCap(fd, DRM_CAP_TIMESTAMP_MONOTONIC, &cap);
 	if (ret == 0 && cap == 1)
@@ -2830,7 +2891,7 @@ find_primary_gpu(struct drm_backend *b, const char *seat)
 	struct udev_enumerate *e;
 	struct udev_list_entry *entry;
 	const char *path, *device_seat, *id;
-	struct udev_device *device, *drm_device, *pci;
+	struct udev_device *device, *drm_device, *pci, *soc = NULL;
 
 	e = udev_enumerate_new(b->udev);
 	udev_enumerate_add_match_subsystem(e, "drm");
@@ -2861,6 +2922,32 @@ find_primary_gpu(struct drm_backend *b, const char *seat)
 				drm_device = device;
 				break;
 			}
+		} else {
+			soc = udev_device_get_parent_with_subsystem_devtype(
+									device,
+									"soc",
+									NULL);
+			if (soc) {
+				id = udev_device_get_sysattr_value(soc,
+								"family");
+				if (id && !strcmp(id, "Tegra")) {
+					if (drm_device) {
+						/* Previously have found the
+						 * drm device, use this device
+						 * as the GBM device
+						 */
+						if (udev_device_get_devnode(
+								device)) {
+							b->gbm.filename = strdup(
+								udev_device_get_devnode(device));
+							break;
+						}
+						continue;
+					}
+					drm_device = device;
+					continue;
+				}
+			}
 		}
 
 		if (!drm_device)
-- 
1.9.1

